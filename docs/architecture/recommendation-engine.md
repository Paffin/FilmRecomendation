# RecommendationEngine — дизайн

## Цель

Давать 5 диверсифицированных рекомендаций <800 мс, используя >100 сигналов, учитывать контекст «режим вечера», объяснять выбор.

## Сигнальные группы (>100 признаков)

- **Жанры/поджанры**: веса по каждому жанру, корреляции лайков/дизлайков, сезонность.
- **Люди**: режиссёры/актёры/сценаристы/студии, частота лайков по ним.
- **Годы/десятилетия**: предпочтения по эпохам, штраф за слишком старые/новые вне вкуса.
- **Продолжительность**: предпочтительный диапазон, отдельные веса для серий vs фильмов.
- **Страны/языки**: склонности по странам, оригинальный язык.
- **Популярность/рейтинг**: TMDB score, популярность, трендовость.
- **Поведение**: лайки/дизлайки, добавления, просмотры, давность взаимодействий (decay), источник (onboarding/search/reco).
- **Контекст «режим вечера»**: mood ↔ жанры/тон, mindset ↔ сложность/жанры, company ↔ семейность/возрастной рейтинг, timeAvailable ↔ runtime.
- **Диверсификация/новизна**: штраф за повторяющиеся франшизы/актеров в текущей выдаче; бонус за новые, но совместимые с вкусом направления.

## Поток расчёта

1. **Профиль пользователя**: пересчитываем/обновляем `UserTasteProfile` при каждом FeedbackEvent и смене статуса/рейтинга. Храним агрегаты (genre weights, people affinity, runtime prefs, eras, countries, tone/pace proxies).
2. **Кандидаты**:
   - Локальные тайтлы с положительными сигналами + популярные/трендовые от TMDB (discover/trending) по медиатипу пользователя.
   - Похожие к недавно лайкнутым (TMDB similar) с кэшем.
   - Фильтры: не в антисписке, не показаны в текущем RecommendationSession, язык/регион ru приоритет.
3. **Скоринг**: линейная комбинация весов по группам (конфиг в коде). Веса по умолчанию и адаптивные поправки от профиля. Runtime/contextные корректировки, свежесть (decay), diversity_penalty.
4. **Diversity rerank**: MMR или soft penalty на близость (жанры/люди/франшизы) между выбранными топ‑k.
5. **Объяснения**: выбираем топ вкладов (3–5) из сигналов с наибольшим весом, маппим в тексты на русском (шаблоны: «Вы часто лайкали {genre} 2010‑х», «Выбор под ваш настрой: лёгкое и короткое», «В главной роли актёр из <Title>»).
6. **Сохранение сессии**: пишем RecommendationSession + RecommendationItem (score, signals). Для дизлайка отмечаем `replaced=true` и возвращаем новую рекомендацию, продолжая session.

## Технологические детали

- Кэш TMDB (in-memory Map + TTL), при промахе — записать Title в БД и raw payload.
- Отдельный конфиг весов и decay (`recommendation.config.ts`):
  - `weightVariants` (A/B) для скоринга.
  - `profileConfig` с half‑life по времени и весами источников (`onboarding`/`search`/`recommendation`).
  - `pickVariantForUser(userId)` с поддержкой режима экспериментов через env `RECOMMENDATION_EXPERIMENT_MODE`.
- Persist‑кэш трендов/популярного:
  - Таблица `CatalogSnapshot` (tmdbId, mediaType, kind, score, snapshotDate).
  - Фоновый job (`RecommendationCatalogTasks`) раз в несколько часов обновляет снапшоты через TMDB и прогревает `Title`.
  - `buildCandidatePool` вначале читает локальные тренды/популярное и только при отсутствии снапшотов ходит в TMDB.
- `RecommendationSignals` — структурированный набор сигналов, сохраняемый в `RecommendationItem.signals` и используемый для объяснений.
- Алгоритм расширяемый: добавить group profiles (позже), платформенные фильтры.

## Эксперименты и граф вкусов

- **Слой экспериментов**:
  - Таблицы `RecommendationExperiment` и `UserExperimentAssignment` описывают активные A/B‑эксперименты и закрепление варианта за пользователем.
  - `RecommendationExperimentService`:
    - читает `config.variants` (набор вариантов, напр. `high_diversity`, `safe_mix`);
    - по `userId` детерминированно назначает вариант и сохраняет его в `UserExperimentAssignment`;
    - подмешивает дефолты `diversityLevel`/`noveltyBias` в `RecommendationContext` и записывает `experimentKey`/`experimentVariant` в `RecommendationSession.context`.
- **Инкрементальное обновление профиля**:
  - `UserTasteProfile` пересчитывается при каждом изменении `UserTitleState` (`UserTitlesService`) и фидбэке по рекомендациям (`RecommendationsService.handleFeedback`) через `RecommendationEngine.rebuildUserTasteProfile(userId)`.
  - `loadUserProfile` больше не сканирует всю историю на каждый запрос рекомендаций, а переиспользует сохранённый профиль (с пересчётом только при смене версии схемы).
- **Логический граф вкусов**:
  - В `AnalyticsService.tasteGalaxy` строится граф: вершины — пользователь, топ‑жанры и связанные с ними тайтлы; рёбра — «предпочитает жанр», «тайтл относится к жанру», «похожие тайтлы» (по пересечению жанров).
  - Результат (`nodes` + `edges`) используется фронтендом для интерактивной «карты‑галактики» вкуса.
- **Что‑если‑режим**:
  - `POST /recommendations/tweak` принимает `{sessionId, titleId, runtime?, tone?}` и на основе исходного `RecommendationSession.context` строит модифицированный контекст (короче/длиннее, легче/тяжелее).
  - Engine подбирает замену только для этой карточки без изменения статуса тайтла, что позволяет пользователю экспериментировать с подборкой как с отдельным видом feedback (`tweak`), не влияя напрямую на историю просмотров.

## Производительность

- Предвыборки: список популярных по медиатипу обновлять периодически (cron/при первом запросе, хранить в БД с TTL).
- Минимизировать сетевые вызовы: 1) только новые tmdbId тянут детали; 2) similar запросы кэшируются.
- Параллелизация скоринга по кандидатам, но итог <=5 результатов.
